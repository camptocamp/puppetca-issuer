/*

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package provisioners

import (
	"context"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"sync"

	"github.com/camptocamp/go-puppetca/puppetca"
	"github.com/go-logr/logr"
	certmanager "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
	"k8s.io/apimachinery/pkg/types"
)

var collection = new(sync.Map)

// PuppetCA implements a Puppet CA provisioner in charge of signing certificate
// requests by calling Puppet CA API's
type PuppetCA struct {
	name        string
	provisioner *PuppetCAProvisioner
}

type PuppetCAProvisioner struct {
	url    string
	cert   string
	key    string
	caCert string
	Log    logr.Logger
}

func NewProvisioner(url string,
	cert string, key string, caCert string, logger logr.Logger) (p *PuppetCAProvisioner) {

	return &PuppetCAProvisioner{
		url: url, cert: cert, key: key, caCert: caCert, Log: logger,
	}
}

// Load returns a Step provisioner by NamespacedName.
func Load(namespacedName types.NamespacedName) (*PuppetCAProvisioner, bool) {
	v, ok := collection.Load(namespacedName)
	if !ok {
		return nil, ok
	}
	p, ok := v.(*PuppetCAProvisioner)
	return p, ok
}

// Store adds a new provisioner to the collection by NamespacedName.
func Store(namespacedName types.NamespacedName, provisioner *PuppetCAProvisioner) {
	collection.Store(namespacedName, provisioner)
}

// Sign sends the certificate requests to the Step CA and returns the signed
// certificate.
func (p *PuppetCAProvisioner) Sign(ctx context.Context, cr *certmanager.CertificateRequest) ([]byte, []byte, error) {
	// decode and check certificate request
	csr, err := decodeCSR(cr.Spec.Request)
	if err != nil {
		return nil, nil, err
	}

	sans := append([]string{}, csr.DNSNames...)
	for _, ip := range csr.IPAddresses {
		sans = append(sans, ip.String())
	}

	subject := csr.Subject.CommonName
	if subject == "" {
		subject = generateSubject(sans)
	}
	log := p.Log.WithValues("puppetcaissuer csr", subject, "url", p.url)

	log.Info("Creating new Puppet CA client")
	client, err := puppetca.NewClient(p.url, p.key, p.cert, p.caCert)
	if err != nil {
		return nil, nil, fmt.Errorf("Failed to initialize Puppet CA client: %v", err)
	}

	// Upload CSR
	log.Info("Submitting CSR to Puppet CA")
	err = client.SubmitRequest(subject, string(cr.Spec.Request))
	if err != nil {
		return nil, nil, fmt.Errorf("Failed to submit CSR to Puppet CA: %v", err)
	}

	// Sign cert
	log.Info("Signing CSR on Puppet CA")
	err = client.SignRequest(subject)
	if err != nil {
		return nil, nil, fmt.Errorf("Failed to sign CSR on Puppet CA: %v", err)
	}

	// Download signed cert
	log.Info("Getting cert from Puppet CA")
	certPem, err := client.GetCertByName(subject)
	if err != nil {
		return nil, nil, fmt.Errorf("Error retrieving certificate")
	}

	return []byte(certPem), nil, nil
}

// decodeCSR decodes a certificate request in PEM format and returns the
func decodeCSR(data []byte) (*x509.CertificateRequest, error) {
	block, rest := pem.Decode(data)
	if block == nil || len(rest) > 0 {
		return nil, fmt.Errorf("unexpected CSR PEM on sign request")
	}
	if block.Type != "CERTIFICATE REQUEST" {
		return nil, fmt.Errorf("PEM is not a certificate request")
	}
	csr, err := x509.ParseCertificateRequest(block.Bytes)
	if err != nil {
		return nil, fmt.Errorf("error parsing certificate request: %v", err)
	}
	if err := csr.CheckSignature(); err != nil {
		return nil, fmt.Errorf("error checking certificate request signature: %v", err)
	}
	return csr, nil
}

// generateSubject returns the first SAN that is not 127.0.0.1 or localhost. The
// CSRs generated by the Certificate resource have always those SANs. If no SANs
// are available `awspca-issuer-certificate` will be used as a subject is always
// required.
func generateSubject(sans []string) string {
	if len(sans) == 0 {
		return "awspca-issuer-certificate"
	}
	for _, s := range sans {
		if s != "127.0.0.1" && s != "localhost" {
			return s
		}
	}
	return sans[0]
}
